# Data types in Postgresql

## Builtin datatypes

* For map like datatype we can use the [**hstore** extension](https://www.postgresqltutorial.com/postgresql-hstore/)

### `BOOLEAN` type

* Boolean values - `true` and `false`.

```Sql
-- Strings with values y, yes, t and true can be type casted to boolean
SELECT
  1::boolean, 'y'::boolean, 'yes'::boolean,'t'::boolean,'true'::boolean;

SELECT
  0::boolean, 'n'::boolean, 'no'::boolean,'f'::boolean,'false'::boolean;
```

### Character types

* `CHAR(n)` - fixed length string with values padded with space if the actual string length is less than n.
* `VARCHAR(n)` - variable length string that can contain upto n characters, but will not be padded with space if the string length is less than n.
* `TEXT` - variable-length character string. Theoretically, text data is a character string with unlimited length.

### [Numeric types](https://www.postgresql.org/docs/9.0/datatype-numeric.html)

* `SMALLINT` - 2-byte signed integer.
* `INT` or `INTEGER` - can hold 4-byte signed integer
* `BIGINT` -8 bytes. Similar to `long` in C, JAVA
* `SERIAL` - holds integer value that is auto generated by postgresql and auto incremented
* `BIGSERIAL` - 8 bytes. Large autoincrementing integer.

* `REAL` - 4 byte floating point integer
* `DOUBLE PRECISION` - 8 bytes
* `decimal` - user-specified precision.
* [`numeric(precision,scale)`](https://www.postgresqltutorial.com/postgresql-numeric/) - user specified precision. The precision must be positive, the scale zero(default) or positive.

> If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits.
> The types decimal and numeric are equivalent. Both types are part of the SQL standard.
> In addition to ordinary numeric values, the floating-point types have several special values:

* `Infinity`
* `-Infinity`
* `NaN`

### [`UUID`](https://www.postgresqltutorial.com/postgresql-uuid/)

* Universal Unique identifiers
* `UUID` guarantees better uniqueness compared to `SERIAL`
* [**uuid-ossp**](https://www.postgresql.org/docs/9.5/uuid-ossp.html) documentation

```Sql
-- This extension contains functions to generate UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- This function generates UUID
-- This function generates the UUID values based on the combination of computer’s MAC address, current timestamp, and a random value
SELECT uuid_generate_v1();

-- To generate a UUID value solely based on random numbers, you can use the uuid_generate_v4()
SELECT uuid_generate_v4();
```

### [Temporal data types](https://www.postgresqltutorial.com/postgresql-date/)

* `date`, [`time`](https://www.postgresqltutorial.com/postgresql-time/), `timestamp` and `interval` are the temporal types.

```Sql
-- common date format used is yyyy-mm-dd
SELECT '2020-06-25'::DATE,
 CAST ('25-JUN-2020' AS DATE),
 CAST ('2020-06-24 14:30:20' AS TIMESTAMP);

SELECT '15 minute'::interval,
  CAST ('2 hour' AS INTERVAL),
  CAST ('1 day' AS interval),
  '2 week'::interval,
  '3 month'::interval;
```

* Some useful functions on date are `NOW()`, `TO_CHAR(date, format)`, `EXTRACT ((YEAR|MONTH|DAY) FROM date)`, `AGE()`

```Sql
SELECT CURRENT_DATE as today,
  NOW()::DATE as now_date,
  NOW()::TIMESTAMP as now_timestamp,
  TO_CHAR('1990-12-25'::date, 'Mon dd,yyyy'),
  AGE('1990-12-25'::date),
  EXTRACT(YEAR FROM '1990-12-25'::date);
```

### Arrays

* [Arrays](../postgresql_tutorial/16_array.md) in postgresql

### [JSON](https://www.postgresqltutorial.com/postgresql-json/)

PostgreSQL provides two JSON data types: `JSON` and `JSONB` for storing JSON data.

### Network specific datatypes

PostgreSQL also provides several special data types related to network.

* `inet–` an IP4 address.
* `macaddr–` a MAC address.

---

## User defined data types

### `CREATE DOMAIN`

* Domain is a data type with optional constraints like `NOT NULL`, `CHECK` etc.

* Domain name is unique with in the schema scope

* Common usecase: Helps in reusing common contraint against a table column

```SQL
CREATE DOMAIN non_empty_string VARCHAR NOT NULL CHECK (value !~ '\s');

CREATE TABLE student (
  id serial PRIMARY KEY,
  name non_empty_string,
  gender non_empty_string
);

INSERT INTO student (name, gender)
  VALUES ('John', 'male');

-- Insert will fail since the gender is NULL
INSERT INTO student (name, gender)
  VALUES ('Jane', NULL);

-- Insert will fail since the name contains space
INSERT INTO student (name, gender)
  VALUES ('Don B', 'male');
```

* Domain can be updated using `ALERT DOMAIN` and deleted using `DROP DOMAIN`.
* `\dD` - psql command to list all the domains

### `CREATE TYPE`

> The CREATE TYPE statement allows you to create a **composite type**, which can be use as the return type of a function.

```SQL
-- creates a type that encaps name and gender
-- Though a simple select from student would serve the purpose this
-- example demonstrates the use of type in postgresql.
CREATE TYPE student_summary AS (
  name varchar,
  gender varchar
);

CREATE OR REPLACE FUNCTION get_student_summary (st_id int)
  RETURNS student_summary
  AS $$
  SELECT
    name,
    gender
  FROM
    student
  WHERE
    id = st_id;

$$
LANGUAGE sql;

SELECT
  *
FROM
  get_student_summary (5);
```

* `ALERT TYPE` - to change the type and `DROP TYPE` - to delete the user defined type.
* `\dT` - psql command to list all the user defined type

---

## References

* [User defined data types](https://www.postgresqltutorial.com/postgresql-user-defined-data-types/)
