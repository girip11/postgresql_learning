# Integer and Numeric types

## Integer types

* `SMALLINT` - 2-byte signed integer.
* `INT` or `INTEGER` - can hold 4-byte signed integer
* `BIGINT` -8 bytes. Similar to `long` in C, JAVA

* No unsigned integer types.
* Trying to store larger value in these types will **raise error**.

### Autogenerated integers

* `SERIAL` - holds integer value that is auto generated by postgresql and auto incremented
* `BIGSERIAL` - 8 bytes. Large autoincrementing integer.

## Numeric types

* `REAL` - 4 byte floating point integer
* `DOUBLE PRECISION` - 8 bytes

In PostgreSQL, `NUMERIC` and `DECIMAL` types are equivalent and both of them are also a part of SQL standard.

* `decimal(precision, scale)` - user-specified precision.
* `numeric(precision, scale)` - user specified precision.

* The precision must be positive, the scale should be zero(default) or positive.
* The **precision is the total number of digits**, while the scale is the number of digits in the fraction part.

```Sql
-- This will print 1000.3
SELECT
  CAST('1000.282' AS NUMERIC(5, 1));
```

> The `NUMERIC` value can have up to 131,072 digits before the decimal point 16,383 digits after the decimal point.
> If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits.
> In addition to ordinary numeric values, the floating-point types have several special values:
>
> * `Infinity`
> * `-Infinity`
> * `'NaN'`

* Special values should always be enclosed within quotes.
* PostgreSQL treats `NaN` values are equal and `NaN` is greater than any non-NaN value.

```Sql
-- Nan equals NaN in comparison
-- returns true
SELECT 'NaN'='NaN' AS result;

-- This prints in the following order
-- NaN
-- 100.2
SELECT
  UNNEST(ARRAY[100.2, 'NaN']) AS numbers
ORDER BY
  numbers DESC;
```

---

## References

* [Integer types](https://www.postgresqltutorial.com/postgresql-integer/)
* [Numeric types](https://www.postgresqltutorial.com/postgresql-numeric/)
